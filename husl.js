// Generated by CoffeeScript 1.3.1
(function() {
  var conv, dotProduct, f, f_inv, fromLinear, huslToRgb, lab_e, lab_k, m, m_inv, maxChroma, refU, refV, refX, refY, refZ, rgbPrepare, rgbToHusl, root, round, stylus, toLinear,
    __slice = [].slice;

  maxChroma = function(L, H) {
    var C, cosH, hrad, m1, m2, m3, result, row, sinH, sub1, sub2, sub3, t, _i, _j, _len, _len1, _ref;
    hrad = H / 360 * 2 * Math.PI;
    sinH = Math.sin(hrad);
    cosH = Math.cos(hrad);
    result = Infinity;
    for (_i = 0, _len = m.length; _i < _len; _i++) {
      row = m[_i];
      m1 = row[0], m2 = row[1], m3 = row[2];
      sub1 = 1.03986e3 * m3 + 9.5503e2 * m2 + 9.07727e2 * m1;
      sub2 = (2.35292e0 * m3 - 7.05875e0 * m1) * cosH;
      sub3 = 1.56861e1 * m3 - 3.13722e0 * m2;
      _ref = [0, 1];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        t = _ref[_j];
        C = (sub1 - 5.18512e3 * t) / ((1.70329e1 * t + sub3) * sinH + sub2);
        if ((0 < C && C < result)) {
          result = C;
        }
      }
    }
    return result;
  };

  m = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.2040, 1.0570]];

  m_inv = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];

  dotProduct = function(a, b) {
    var i, ret, _i, _ref;
    ret = 0;
    for (i = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      ret += a[i] * b[i];
    }
    return ret;
  };

  round = function(num, places) {
    var n;
    n = Math.pow(10, places);
    return Math.round(num * n) / n;
  };

  refX = 0.95047;

  refY = 1.00000;

  refZ = 1.08883;

  refU = 0.19784;

  refV = 0.46834;

  lab_e = 0.008856;

  lab_k = 903.3;

  f = function(t) {
    if (t > lab_e) {
      return Math.pow(t, 1 / 3);
    } else {
      return 7.787 * t + 16 / 116;
    }
  };

  f_inv = function(t) {
    if (Math.pow(t, 3) > lab_e) {
      return Math.pow(t, 3);
    } else {
      return (116 * t - 16) / lab_k;
    }
  };

  fromLinear = function(c) {
    if (c <= 0.0031308) {
      return 12.92 * c;
    } else {
      return 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
    }
  };

  toLinear = function(c) {
    var a;
    a = 0.055;
    if (c > 0.04045) {
      return Math.pow((c + a) / (1 + a), 2.4);
    } else {
      return c / 12.92;
    }
  };

  rgbPrepare = function(tuple) {
    var ch, n, _i, _j, _len, _len1, _results;
    tuple = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tuple.length; _i < _len; _i++) {
        n = tuple[_i];
        _results.push(round(n, 3));
      }
      return _results;
    })();
    for (_i = 0, _len = tuple.length; _i < _len; _i++) {
      ch = tuple[_i];
      if (ch < 0 || ch > 1) {
        throw new Error("Illegal rgb value");
      }
    }
    _results = [];
    for (_j = 0, _len1 = tuple.length; _j < _len1; _j++) {
      ch = tuple[_j];
      _results.push(Math.round(ch * 255));
    }
    return _results;
  };

  conv = {
    'xyz': {},
    'luv': {},
    'lch': {},
    'husl': {},
    'rgb': {},
    'hex': {}
  };

  conv.xyz.rgb = function(tuple) {
    var B, G, R;
    R = fromLinear(dotProduct(m[0], tuple));
    G = fromLinear(dotProduct(m[1], tuple));
    B = fromLinear(dotProduct(m[2], tuple));
    return [R, G, B];
  };

  conv.rgb.xyz = function(tuple) {
    var B, G, R, X, Y, Z, rgbl;
    R = tuple[0], G = tuple[1], B = tuple[2];
    rgbl = [toLinear(R), toLinear(G), toLinear(B)];
    X = dotProduct(m_inv[0], rgbl);
    Y = dotProduct(m_inv[1], rgbl);
    Z = dotProduct(m_inv[2], rgbl);
    return [X, Y, Z];
  };

  conv.xyz.luv = function(tuple) {
    var L, U, V, X, Y, Z, varU, varV;
    X = tuple[0], Y = tuple[1], Z = tuple[2];
    varU = (4 * X) / (X + (15 * Y) + (3 * Z));
    varV = (9 * Y) / (X + (15 * Y) + (3 * Z));
    L = 116 * f(Y / refY) - 16;
    U = 13 * L * (varU - refU);
    V = 13 * L * (varV - refV);
    return [L, U, V];
  };

  conv.luv.xyz = function(tuple) {
    var L, U, V, X, Y, Z, varU, varV, varY;
    L = tuple[0], U = tuple[1], V = tuple[2];
    if (L === 0) {
      return [0, 0, 0];
    }
    varY = f_inv((L + 16) / 116);
    varU = U / (13 * L) + refU;
    varV = V / (13 * L) + refV;
    Y = varY * refY;
    X = 0 - (9 * Y * varU) / ((varU - 4) * varV - varU * varV);
    Z = (9 * Y - (15 * varV * Y) - (varV * X)) / (3 * varV);
    return [X, Y, Z];
  };

  conv.luv.lch = function(tuple) {
    var C, H, Hrad, L, U, V;
    L = tuple[0], U = tuple[1], V = tuple[2];
    C = Math.pow(Math.pow(U, 2) + Math.pow(V, 2), 1 / 2);
    Hrad = Math.atan2(U, V);
    H = Hrad * 360 / 2 / Math.PI;
    if (H < 0) {
      H = 360 + H;
    }
    return [L, C, H];
  };

  conv.lch.luv = function(tuple) {
    var C, H, Hrad, L, U, V;
    L = tuple[0], C = tuple[1], H = tuple[2];
    Hrad = H / 360 * 2 * Math.PI;
    U = Math.cos(Hrad) * C;
    V = Math.sin(Hrad) * C;
    return [L, U, V];
  };

  conv.husl.lch = function(tuple) {
    var C, H, L, S, max;
    H = tuple[0], S = tuple[1], L = tuple[2];
    max = maxChroma(L, H);
    C = max / 100 * S;
    return [L, C, H];
  };

  conv.lch.husl = function(tuple) {
    var C, H, L, S, max;
    L = tuple[0], C = tuple[1], H = tuple[2];
    max = maxChroma(L, H);
    S = C / max * 100;
    return [H, S, L];
  };

  conv.rgb.hex = function(tuple) {
    var ch, hex, _i, _len;
    hex = "#";
    tuple = rgbPrepare(tuple);
    for (_i = 0, _len = tuple.length; _i < _len; _i++) {
      ch = tuple[_i];
      ch = ch.toString(16);
      if (ch.length === 1) {
        ch = "0" + ch;
      }
      hex += ch;
    }
    return hex;
  };

  conv.hex.rgb = function(hex) {
    var b, g, r;
    if (hex.charAt(0) === "#") {
      hex = hex.substring(1, 7);
    }
    r = hex.substring(0, 2);
    g = hex.substring(2, 4);
    b = hex.substring(4, 6);
    return [r, g, b].map(function(n) {
      return parseInt(n, 16) / 255;
    });
  };

  huslToRgb = function() {
    var tuple;
    tuple = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return conv.xyz.rgb(conv.luv.xyz(conv.lch.luv(conv.husl.lch(tuple))));
  };

  rgbToHusl = function() {
    var tuple;
    tuple = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return conv.lch.husl(conv.luv.lch(conv.xyz.luv(conv.rgb.xyz(tuple))));
  };

  root = {};

  try {
    stylus = require('stylus');
    root = function() {
      return function(style) {
        return style.define('husl', function(H, S, L) {
          var B, G, R, _ref;
          _ref = rgbPrepare(huslToRgb([H.val, S.val, L.val])), R = _ref[0], G = _ref[1], B = _ref[2];
          return new stylus.nodes.RGBA(R, G, B, 1);
        });
      };
    };
  } catch (_error) {}

  root.husl = function(H, S, L) {
    return conv.rgb.hex(huslToRgb(H, S, L));
  };

  root.rgb = function(R, G, B) {
    return rgbToHusl(R, G, B);
  };

  root.hex = function(hex) {
    return rgbToHusl(conv.hex.rgb(hex));
  };

  root._conv = conv;

  root._maxChroma = maxChroma;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = root;
  }

  if (typeof jQuery !== "undefined" && jQuery !== null) {
    jQuery.husl = root;
  }

}).call(this);
